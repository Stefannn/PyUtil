'''
@author Stefan Hegglin
Utilities to plot and analyse profiling information
generated by cProfile using e.g.
python -m cProfile -o output.txt script.py
'''
from __future__ import division
import pstats
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

sns.set_color_codes("pastel")
sns.set(style="whitegrid")

def load_file(filename):
    '''
    Loads the file specified by filename into a pstats object
    Strips the extraneous path from the module names
    '''
    try:
        return pstats.Stats(filename).strip_dirs()
    except IOError:
        raise

def barplot_top_n_functions(df, n, sort_criterium='tot_time'):
    '''
    Barplot of the n most time consuming functions (sorted by sort_criterium)
    df: panda dataframe (e.g. via get_df_from_stats())
    '''
    total_time = df['tot_time'].sum()
    data = df.sort(columns=[sort_criterium], ascending=False).iloc[0:n]
    topn_time = data['tot_time'].sum()
    frac_time = topn_time / total_time

    f, ax = plt.subplots()
    sns.barplot(data=data, x=sort_criterium, y='flf', color='b')
    sns.despine(left=True, bottom=True)
    ax.set(ylabel="", xlabel=sort_criterium + " [s]")
    # write the fraction of total time spent in these n functions
    rect = ax.patches[0] # last rectangle to get position of text
    txt = str(int(100*frac_time)) + "% of total runtime"
    ax.text(rect.get_width()*0.7, rect.get_height()*1.5, txt,
            ha="center", va="center")

    plt.tight_layout()
    plt.show()


def get_df_from_stats(stats):
    ''' Create a panda dataframe out of a Stats class (pstats)'''
    rows = []
    columns = ["ncalls", "pcalls", "tot_time", "tot_time_per",
               "cum_time", "cum_time_per", "file", "line", "function", "flf"]
    for k, v in stats.stats.items():
        fl = k[0]
        line = int(k[1])
        func = k[2]
        pcalls = v[0] # primitive number of calls (excluding recursive calls)
        ncalls = v[1] # total number of calls (including recursive calls)
        assert (pcalls <= ncalls)
        tot_time = v[2]
        cum_time = v[3]
        tot_time_per = v[2] / v[0] if v[0] > 0 else 0
        cum_time_per = v[3] / v[0] if v[0] > 0 else 0
        rows.append(
            [ncalls, pcalls, tot_time, tot_time_per,
             cum_time, cum_time_per, fl, line, func,
             str(fl) + ':' + str(line) + '\n' + str(func) + '()'])
    df = pd.DataFrame(rows, columns=columns)
    return df
